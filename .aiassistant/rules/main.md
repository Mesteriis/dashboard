---
apply: always
---

# AI Code Assistant Rules (AVM Style)

Назначение: единые правила для AI code assistants в проекте, чтобы код был простым, типизированным, тестируемым и без лишней архитектурной сложности.

Стек/предпочтения:
- Python 3.13+
- Typed Python (typing везде)
- uv (управление зависимостями)
- Docker multi-stage (best practices)
- Тесты в ROOT_DIR/tests
- CI: GitHub + Gitea
- Registry: Zot (zotregistry)
- Deploy: Dokploy
- Структура src/ как в этом документе

----------------------------------------------------------------

## 0. Золотые правила

1) Делай минимально достаточное решение (KISS) вместо “enterprise”.
2) Не делай “заодно”: никаких побочных рефакторингов, переносов, переименований.
3) Не выдумывай то, чего нет в проекте (эндпоинты, таблицы, env). Если данных не хватает — делай безопасное допущение и явно пиши его.
4) Любая измененная логика -> тест.
5) Не добавляй зависимости, если можно без них.
6) Не меняй публичные контракты (API/scheme/форматы) без явного запроса.

----------------------------------------------------------------

## 1. Структура проекта (обязательная)

AI должен следовать существующей структуре и не менять ее без запроса.

src/
  api/         транспортный слой (FastAPI routers, dependencies)
  config/      settings, env, logging, wiring
  frontend/    SSR/Vue CDN/UI-логика (если есть)
  scheme/      Pydantic DTO/контракты запросов-ответов
  service/     бизнес-логика (use-cases)
  static/      статика
  templates/   Jinja2
  tools/       утилиты/клиенты интеграций (НЕ свалка)
  main.py      точка входа, app factory, startup

tests/         тесты в ROOT_DIR
Dockerfile     multi-stage
pyproject.toml
README.md

Границы слоев:
- api/      не содержит бизнес-логики и SQL; только HTTP слой, маппинг ошибок, Depends
- scheme/   только Pydantic (контракты), без ORM/SQL
- service/  бизнес-правила, оркестрация, транзакции (если применимо)
- tools/    узкие утилиты и интеграционные клиенты, без бизнес-правил
- config/   конфигурация, settings, wiring

----------------------------------------------------------------

## 2. Принципы разработки (с примерами)

### 2.1 DRY (Don’t Repeat Yourself)
Идея: не дублировать знания и правила.

Плохо (дублирование логики в разных местах):
- одна и та же проверка роли в 3 местах с разными условиями

Хорошо:
- вынести правило в одну функцию/метод

Пример (хорошо):
def is_admin(user: User) -> bool:
    return user.role == "admin"

Важно:
- DRY не означает “строить абстракции ради абстракций”.
- если повтор < 3 раз, допускается локально без усложнения.

### 2.2 KISS (Keep It Simple)
Плохо:
- фабрики/стратегии/DI-контейнер при одной реализации

Хорошо:
- обычная функция/класс, явные аргументы, простая логика.

### 2.3 YAGNI (You Aren’t Gonna Need It)
Плохо:
- “на будущее” плагин-система, CQRS, EventBus без реальной потребности

Хорошо:
- минимальная реализация сейчас + точка расширения при появлении второй реальной реализации.

### 2.4 SOLID (прагматично)

S (Single Responsibility):
Плохо: один класс делает все (HTTP + SQL + бизнес-правила)
Хорошо: сервис делает use-case, api делает HTTP

O (Open/Closed):
Плохо: переписывать рабочий код “под красивую архитектуру”
Хорошо: расширять через отдельные небольшие изменения, не ломая старое

L (Liskov):
Плохо: наследник меняет контракт, ломает ожидания
Хорошо: наследование только при полной совместимости поведения

I (Interface Segregation):
Плохо: “IRepository” на 30 методов
Хорошо: маленькие протоколы по нужным методам

D (Dependency Inversion):
Плохо: Protocol/абстракции “чтобы было”
Хорошо: Protocol только если есть 2 реализации или тестовая необходимость

### 2.5 Separation of Concerns
- api/ не содержит бизнес-правил
- service/ не содержит HTTP кодов
- scheme/ не содержит ORM/DB моделей

### 2.6 High Cohesion / Low Coupling
- код по смыслу рядом
- минимум связей между модулями
- никаких циклических импортов

### 2.7 Composition over Inheritance
Плохо: глубокие иерархии наследования
Хорошо: композиция через зависимости (в конструктор/функцию)

### 2.8 Law of Demeter
Плохо:
order.customer.address.city.name
Хорошо:
order.customer_city()

### 2.9 Fail Fast + Explicit Errors
Плохо:
try: ...
except Exception: return None
Хорошо:
raise UserNotFound(user_id)

### 2.10 Idempotency
- повторный запрос не должен ломать данные (особенно для API и фоновых задач)
- если нужно: Idempotency-Key и проверка повторов

### 2.11 Observability-first
- структурные логи
- контекст (request-id, user-id, entity-id)
- без спама

----------------------------------------------------------------

## 3. Typed Python (строго)

1) Любой новый/измененный код обязан быть типизирован.
2) Аннотируй параметры и возвращаемые значения.
3) Используй:
- collections.abc (Sequence, Mapping)
- typing (Protocol, TypedDict) только при необходимости
4) Any допускается только при явной причине и с комментарием.

Плохо:
def f(x):
    return x

Хорошо:
def f(x: int) -> int:
    return x

----------------------------------------------------------------

## 4. Scheme (Pydantic) правила

1) scheme/ содержит только DTO/контракты.
2) scheme/ не содержит ORM моделей и не импортирует DB слой.
3) Валидация и нормализация данных -> через Pydantic модели на границе (api/).

Плохо:
- смешивать Pydantic и ORM в одном классе

Хорошо:
- UserCreate / UserRead / UserUpdate отдельно

----------------------------------------------------------------

## 5. API layer (FastAPI) правила

API слой обязан:
- принимать request DTO из scheme/
- вызывать service/
- маппить ошибки сервиса в HTTP ответы
- не содержать бизнес-правила и SQL

Плохо:
- делать SQL/хеширование/интеграции прямо в роутере

Хорошо:
- роутер тонкий, вся логика в service/

----------------------------------------------------------------

## 6. Service layer правила

Service слой:
- реализует бизнес-правила
- оркестрирует репозитории и tools
- не знает про HTTP коды и Response

Service не возвращает “Response”, не пишет “jsonify” и т.п.

----------------------------------------------------------------

## 7. Tools правила (не свалка)

tools/ допустим для:
- клиентов внешних API
- утилит парсинга/сериализации
- маленьких хелперов с узкой ответственностью

Запрещено:
- business logic в tools/
- огромный utils.py/helpers.py/common.py как свалка

Хорошо:
tools/email/client.py
tools/http/retry.py

Плохо:
tools/utils.py

----------------------------------------------------------------

## 8. Тесты (ROOT_DIR/tests)

Правила:
1) Любая измененная логика -> тест.
2) Багфикс -> тест, который падает без фикса.
3) Тесты не зависят от интернета и реального времени.
4) Unit и integration тесты разделены папками или маркерами.

Рекомендуемая структура:
tests/
  unit/
  integration/
  conftest.py

Плохо:
assert True
Хорошо:
тест проверяет контракт и конкретное поведение

----------------------------------------------------------------

## 9. Docker (multi-stage) правила

Требования:
- multi-stage build
- runtime без build-tools
- запуск non-root
- минимальный runtime image
- кеширование зависимостей (uv)
- healthcheck (если уместно)

Запрещено:
- запуск под root
- установка компиляторов в runtime
- “build on server” вместо CI

----------------------------------------------------------------

## 10. uv / зависимости

Требования:
- зависимости управляются через pyproject.toml
- фиксация через lock (если используется uv.lock)
- CI использует “frozen” режим (например, uv sync --frozen)

Запрещено:
- мешать pip requirements.txt с uv, если проект ведется на uv (кроме миграции/особого случая)

----------------------------------------------------------------

## 11. CI/CD (GitHub + Gitea + Zot registry + Dokploy)

CI обязан:
- ruff (lint/format)
- typecheck (mypy/pyright, что принято)
- pytest
- docker build (multi-stage)
- push image в Zot registry
- tag strategy: commit sha + (опционально) semver + latest (если принято)

Deploy (Dokploy):
- деплой из registry image
- env через secrets
- миграции БД отдельным шагом (если есть)

Плохо:
- вручную собирать на сервере
- копипастить файлы на прод

Хорошо:
- image tag = commit sha
- rollback через откат на предыдущий tag

----------------------------------------------------------------

## 12. Формат ответа AI (обязательный)

AI обязан выдавать:
1) Что изменено (3-7 пунктов)
2) Какие файлы изменены и полный код/патч
3) Как проверить локально (команды)
4) Риски и обратная совместимость

Запрещено:
- “примерно так”
- куски без контекста, если пользователь просит готовое решение

----------------------------------------------------------------

## 13. Анти-паттерны (строго запрещены)

- God-class
- utils/helpers/common.py как свалка
- DI-контейнер без причины
- ServiceLocator
- скрытые side-effects
- silent except Exception: pass
- магические числа без объяснения
- глобальные синглтоны
- рефакторинг “заодно”

----------------------------------------------------------------

## 14. Definition of Done (чеклист)

Изменение готово, если:
- код запускается локально
- тесты проходят
- ruff/format проходит
- typecheck проходит (если включено)
- не добавлены лишние зависимости
- не сломаны публичные контракты без запроса
- README обновлен, если менялось поведение
- нет мертвого кода и мусора

----------------------------------------------------------------

## 15. Примеры сценариев “как делать / как не делать”

### 15.1 Добавить endpoint
Как делать:
- api/: добавить router + Depends
- scheme/: добавить request/response DTO
- service/: добавить use-case
- tests/: добавить тест

Как не делать:
- писать бизнес-логику в router
- принимать dict вместо DTO

### 15.2 Добавить интеграцию с внешним API
Как делать:
- tools/: клиент (timeouts, retries, типы)
- service/: orchestration и правила
- tests/: мок клиента

Как не делать:
- requests/httpx прямо в роутере
- секреты в коде

### 15.3 “Сделай на будущее”
Как делать:
- минимум сейчас
- небольшая точка расширения
- документировать где расширять

Как не делать:
- CQRS + EventBus + 8 интерфейсов “на всякий случай”
